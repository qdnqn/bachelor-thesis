%wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww
% Ansible
%wwwwwwwwwwwwwwwww

\documentclass[../diplomskiRad.tex]{subfiles}

\begin{document}

\chapter{Uvod}
Ansible je open-source alat za menadžment infrastrukture, provizioinranje okruženja i automatizacije deployment-a aplikacija. Omogućava uvođenje koncepta Infrastructure as Code (IaC) kao i automatizaciju raznih procesa. 
\\\\
Ansible je izgrađen na sljedećim principima:
\begin{itemize}
    \item \textbf{Bez agenta}: U potpunosti se oslanja na SSH protokol za izvršavanje zadanih akcija. U slučaju Windows operativnog sistema se oslanja na WinRM protokol. Ne koristi druge portove, servise niti specijalne agente da bi interreagovao sa "target" host-om.
    \item \textbf{Minimalistički pristup}: Upravljanje novim okruženjima ne  zahtjeva instalaciju novog software-a.
    \item \textbf{Deskriptivnost}: Omogućivanje deskriptivnog opisa konfiguracije infrastrukture, instaliranja potrebnih zavisnosti ili bilo kojih drugih akcija, koji je čitljiv od strane ljudi i računara.
    \item \textbf{Jednostavnost}: Krivulja učenja je jednostavna i alat je intuitivan za korištenje.
\end{itemize}
\\ \\
Ansible je izgrađen koristeći deklarativnu paradigmu što znači da je zadatak korisnika da definiše niz koraka sa zadanim krajnjim rezultatom bez da se fokusira na koji način će se doći do krajnjeg rezultata. Drugi alati, kao što je \textbf{Cheff}, koriste imeprativnu paradigmu. Deklarativni pristup od korisnika sakriva način implementacije logike dolaska do krajnjeg rezultata koji je zadan kao poželjan. Ova činjenica za sobom povlači potrebu više iteracija da bi alat mogao sam odrediti koje su akcije ovisne o drugim akcijama.
\\\\
Također kao bitnu stavku potrebno je izdvojiti da Ansible garantira koncept idempotencije u core modulima ali u custom modulima ako su dizajnirani ispravno. Idemopotencija je koncept posuđen iz matematike. Ova osobina garantira da je rezultat određene akcije kada se odradi jednom isti kao i kada se akcija odradi više puta. Primjer idempotencije je množenje sa nulom.
\newpage
\clearpage
\nodeident 
Ansible nam omogućava da deskriptivno definišemo model za definiciju i opis infrastrukture. Primjer zadane konfiguracije za Ansible u obliku YAML file-a, na šta ćemo se detaljnije fokusirati kasnije, je dat ispod:\\
\setlistingyaml
\begin{lstlisting}
- name: install packages
	yum:
		name: "{{ item }}"
		state: latest
	with_items:
		- dstat
		- lsof
		- mailx
		- rsync
\end{lstlisting}
Primjer je zadužen za instalaciju software-a na linux operativnom sistemu. Korištenjem komande \textbf{yum} inicira se instalacija sljedećih paketa:
\begin{itemize}
    \item dstat
    \item lsof
    \item mailx
    \item rsync
\end{itemize}
Dati primjer je jednostavan oblik konfiguracije infrastrukture ali je validan IaC. Iz primjera možemo zaključiti da imamo mogućnost upravljanja kodom koji manipuliše infrastrukturom na isti način kao što progamer upravlja izvornim kodom.
\\\\
IaC predstavlja veliko unaprijeđenje u odnosu na manuelni način konfiguracije infrastrukture jer nam omogućava:
\begin{itemize}
\item Korištenje kontrole verzije (eng: Source control)
\item Timski rad na izgradnji infrastrukture
\item Ponovna upotrebljivost
\item Skaliranje
\item Testiranje 
\item Konzistentnost
\end{itemize}
\section{Okruženje}
Za pokretanja svih primjera u ovom radu korišteno je sljedeće okruženje:
\begin{itemize}
    \item Ubuntu 18.04 LTS
    \item Ansible 2.9.11
    \item Python verzija 2.7.17 
\end{itemize}
Verzije dodatno korištenih alata biće navedene po pojavljivanju.
\newpage
\section{Teorijska pozadina}
Pored samog alata za automatizaciju da bi shvatili širu sliku potrebno je upoznati se sa pojedinim terminima, koji su relativno novi, te pokušati definisati korištene koncepte i paradigme iz različitih oblasti. Objašnjenja su veoma kratka i precizna jer dublja analiza navedenih stavki izlazi iz opsega ovog rada.
\subsection{Kontrola verzije}
Izvorni kod je kolekcija koda koji je pisan u bilo kojem programskom jeziku. Kontrola verzije (eng.Source control) je praksa praćenja i upravljanja promjenama u izvornom kodu. Sistem kontrole verzije pruža uvid u historiju izmjena izvornog koda i omogućava rješavanje konflikata kada se spajaju izmjene od različitih programera. Alat koji implementira navedene stavke naziva se Version control system (VCS).
\\\\
Popularni VCS su Git, SVN, CVS, itd. Značajno se koriste i online implementacije navedenih alata sa proširenim mogućnostima kao što su Github ili GitLab.
\subsection{Build}
U razvoju software-a \textbf{build} predstavlja proces konverzije izvornog koda u artifakte koji su spremni za korištenje kao programi koji se mogu izvršavati. Build je end-to-end proces koji se sastoji iz više koraka kao što su najčešće:
\begin{itemize}
    \item Kontrola verzije
    \item Kvaliteta koda
    \item Kompajliranje i linkanje
\end{itemize}
Za velike projekte build proces postaje kompleksan. Na takvim projektima koriste se alati koji automatiziraju build proces, kao što su
\begin{itemize}
    \item make
    \item maven
    \item gradle
\end{itemize}
koji nam znatno olakšavaju cijeli proces.
\\\\
Kao rezultat build procesa dobijemo build \textbf{artifakte}. Artifakt je nusprodukt build procesa i može imati različite forme u zavisnosti od toga kako je definisan build proces. Sljedeći korak predstavlja distribuciju artifakta. Artifakti mogu imati različit oblik pa se i proces distribucije istih znatno razlikuje u zavisnosti od oblika artifakta. Artifakt može biti biblioteka, izvršni file ili paket različitih file-ova. Samim time proces distribucije je različit za svaki tip artifakta.
\subsection{DevOps}
DevOps je relativno mlado polje. Predstavlja spoj Development, Operations i Quality assurance timova. Trenutno ne postoji unificirana definicija za DevOps. Međutim esencijalna praksa svakog DevOps tima predstavlja:
\begin{itemize}
    \item Continuous integration
    \item Continuous delivery
    \item Continuous deployment
    \item Infrastructure as Code
    \item Monitoring i mjerenja
    \item Automatizacija procesa
\end{itemize}
\subsubsection{Continuous integration}
Continuous Integration (CI) je praksa sjedinjavanja izvornog koda različitih programera, u sistemu za kontrolu verzije, u dogovorenim intervalima. U zavisnosti od tipa projekta i dogovora tima proces može biti okinut više puta na dan, jednom dnevnom ili sedmično.  
\subsubsection{Continous delivery}
Continuous Delivery (CD) je proces automatizacije build-a izvornog koda, testiranja, konfiguracije i pripreme za deployment artifakta u produkcijsko okruženje. Continous delivery osigurava da u svakom trenutku imate artifakte koji su spremni za deployment u produkcijsko okruženje.
\subsubsection{Continous Deployment}
Continous Deployment predstavlja deployment artifakta u produkcijsko okruženje.
\subsubsection{Monitoring i mjerenja}
Monitoring nam daje povratne informacije iz različtih okruženja. Dostavlja informacije o performansama aplikacije i načinu korištenja aplikacije.
\\\\
Monitoring predstavlja značajan dio procesa. U svakom trenutku potrebne su nam informacije o stanju aplikacije u različitim okruženjima. Ako se desi neki problem potrebno je obavijestiti one koji su zaduženi za održavanje aplikacije u optimalnom stanju. Također monitoring i mjerenja nam omogućavaju uvid u tačke aplikacije koje je potrebno optimizirati tzv \textbf{eng. bottlenecks}.
\subsubsection{Infrastructure as Code}
Infrastructure as Code (IaC) smo već spomenuli u uvodu međutim definirat ćemo termin precizno: IaC predstavlja način da deskriptivnim modelom definišemo konfiguraciju infrastrukture (Mreže, Virtualnih mašina, Kontejnera, Fizičkih servera, Load balancer-a, itd.). Koncepte iz razvoja software-a, kao CI ili CD, možemo primjeniti na razvoj infrastrukture. \\\\
IaC nam omogućava da proces razvoja infrastrukture može biti automatiziran, konzistentan i ponovljiv.
\subsubsection{Automatizacija procesa}
Automatizacija procesa u DevOps timu je konstantan proces. Potrebno je konstantno analizirati procese da bi otkrili one koji se ponavljaju i koje je moguće automatizirati da bi se proces razvoja aplikacija ubrzao.
\
\subsection{Mikroservisna i monolitna arhitektura}
\subsubsection{Monolitna arhitektura}
Monolitna arhitektura opisuje arhitekturu aplikacije, koja se sastoji od više modula kombiniranih u obliku biblioteka ili slojeva, pokrenute unutar jednog procesa ili kontejnera. Loša strana ovakvog dizajna aplikacije je skalabilnost. Često je potreba za skaliranjem samo u određenim modulima aplikacije. Međutim ovakvu arhitekturu je moguće skalirati samo kao cjelinu što nam ostavlja mnogo neiskorištenih resursa. Ispod je dat model monolitne arhitekture.
\begin{figure}[H]
\centering
 \includegraphics[scale=0.75]{slike/monolithic.pdf}
 \caption{Monolitna arhitektura}
 \label{ref_slika1}
\end{figure}
\noident Kada bi se vršilo skaliranje ove aplikacije bilo bi potrebno skalirati kompletan blok \textbf{Modules}, \textbf{Web App} i \textbf{API} (Unutar ServerHost bloka). Dakle rješenje skalabilnosti, u ovom slučaju, predstavlja vertikalna skalabilnost. Međutim drugačijim pristupom dizajna same aplikacije možemo riješiti navedeni problem. 
\subsubsection{Mikroservisna arhitektura}
Mikroservisna arhitektura je arhitektura u kojoj se svaki od modula tretira kao zasebna aplikacija. Svaki modul ima veoma jasan i "mikro" zadatak odakle i potiče naziv mikroservis. Mikroservisna arhitektura predstavlja suprotnost od monolitne arhitekture i ima mnoge prednosti u enterprise aplikacijama. Ispod je dat primjer modela mikroservisne arhitekture.
\begin{figure}[H]
\centering
 \includegraphics[scale=0.75]{slike/microservice.pdf}
 \caption{Mikroservisna arhitektura}
 \label{ref_slika2}
\end{figure}
Ako analiziramo blok šemu i uporedimo sa monolitnom arhitekturom možemo zaključiti da se u mikroservisnoj arhitekturu svaki modul ponaša kao proces. Svaki modul je izoliran od drugih i naziva se mikroservis. Svo rutiranje između mikroservisa kao i vanjskog svijeta se odvija preko API modula. Svaki mikroservis je samoodrživ i posjeduje svoju bazu podataka.
\\\\
Kako se svaki modul nalazi u izoliranom okruženju možemo vršiti skaliranje samo onih modula koji predstavljaju bottleneck aplikacije. Skaliranje se vrši horizontalno. \\\\
Na slici \ref{ref_slika2} je prikazan pojednostavljeni model mikroservisne arhitekture sa specifičnom struktrom. Struktura same arhitekture može varirati u ovisnosti od izbora pri dizajnu.
\\\\
Najčešći način izolacije mikroservisa od drugih je korištenjem kontejnera. Zajedno sa kontejnerima defacto standard za deployment i orkestraciju kontejnera postao je Kubernetes. U ovom radu fokus je stavljen na Docker i Kubernetes, te sljedeće čitavo poglavlje posvećeno je baš ovim tehnologijama.
\end{document}