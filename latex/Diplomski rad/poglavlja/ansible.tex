%wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww
% Ansible
%wwwwwwwwwwwwwwwww

\documentclass[../diplomskiRad.tex]{subfiles}
\setlistingyaml

\begin{document}

\chapter{Ansible}
Ansible je alat za menadžment konfiguracije koji se nastao pod okriljem Red Hat organizacije. Pri samom dizajnu alata prilazilo se na način da se što je moguće više pojednostavi definisanje konfiguracije i implementacija iste. Zbog toga ansible za definisanje konfiguracije koristi yaml način zapisa informacija. Key-value parovi omogućavaju definiciju konfiguracije infrastrukture u formatu lahko čitljivom ljudima. \\\\Pored jednostavnosti zapisa koda infrastrukture, Ansible se u potpunosti oslanja na SSH protokol za upravljanje  okruženjima sa kontrolne mašina. Kontrolna mašina je ona na kojoj je instaliran Ansible i sa nje se vrši distribucija konfiguracije na upravljive mašine. Sav promet prolazi direktno preko SSH protokola što isključuje potrebu instaliranja agenata na upravljivim mašinama.
\subsection{Instalacija}
U ovom radu Ansible je instaliran na Ubuntu 18.04 LTS verziji. Prema uputama na oficijelnoj stranici, Ansbile je moguće instalirati na sljeći način (Ubuntu)
\begin{lstlisting}
sudo apt update
sudo apt install software-properties-common
sudo apt-add-repository --yes --update ppa:ansible/ansible
sudo apt install ansible
\end{lstlisting}
Na ovaj način instalirat će se Ansible i koristiti pyton 2 interpreter. Instalacija Ansible-a koja koristi python 3 interpreter se može uraditi na sljedeći način
\begin{lstlisting}
pip3 install ansible
\end{lstlisting}
Pokretanjem sljedeće komande u linux terminalu:
\begin{lstlisting}
ansible --version
\end{lstlisting}
bi trebalo da ispiše nešto slično sljedećem ispisu na terminalu:
\begin{lstlisting}
ansible 2.10.2
  config file = /etc/ansible/ansible.cfg
  python version = 3.6.9 
\end{lstlisting}
\subsection{Postavka okruženja}
Pored potrebne Ansible instalacije u ovom radu korištena je simulacija okruženja korištenjem Vagrant-a. Vagrant je alat za kreiranje i upravljanje okruženjima na virtualnim mašinama. Na sličan način kao što Docker koristi Dockerfile, Vagrant koristi Vagrantfile za definiciju i konfiguraciju virtualnih mašina.
\\\\
Vagrant se oslanja na hipervizore za kreiranje virtualnih okruženja. U ovom radu koristit ćemo virtualbox. Instalacija na Ubuntu mašinu pokreće se sljedećom komandom.
\begin{lstlisting}
sudo apt-get install virtualbox
\end{lstlisting}
Nakon toga potrebno je instalirati Vagrant. Pozicionirajte se u home direktorij i pokrenite sljedeće komande.
\begin{lstlisting}
cd ~ 
curl -O https://releases.hashicorp.com/vagrant/2.2.9/vagrant_2.2.9_x86_64.deb
sudo apt install ./vagrant_2.2.6_x86_64.deb
rm vagrant_2.2.6_x86_64.deb
mkdir vagrant 
cd vagrant
touch Vagrantfile
\end{lstlisting}
U Vagrantfile-u definišemo naše virtualne mašine. U ovom radu korištena je sljedeća konfiguracija (Vagrantfile).
\begin{lstlisting}
Vagrant.configure("2") do |config|
  config.vm.define "u1" do |u1|		
    u1.vm.box = "hashicorp/bionic64"
    u1.vm.network "private_network", ip: "192.168.33.10"
  end 

  config.vm.define "u2" do |u2|
    u2.vm.box = "hashicorp/bionic64"
    u2.vm.network "private_network", ip: "192.168.33.11" 
  end
end
\end{lstlisting}
Definisane su dvije virtualne mašine sa operativnim sistemom Ubuntu 18.04 LTS. Mrežni mod koji je korišten je private network. Private network omogućava samo konekciju sa host mašine na virtualne mašine. Definisane su dvije jedinstvene IP adrese, iz privatnog spektra, na mreži 192.168.33.0. Na ovaj način možemo pristupiti virtualnim mašinama direktno sa host mašine.
\\\\
Kada pokrenemo, unutar direktorija vagrant,
\begin{lstlisting}
vagrant up
\end{lstlisting}
Vagrant će automatski kreirati dvije virtualne mašine za nas. Trenutno koristimo host mašinu na kojoj je instaliran Ansible. Također su pokrenute dvije virtualne mašine na istoj host mašini koje su korištene za simulaciju upravljvih mašina.
\newpage
\subsection{Inventories}
Da bi vršili bilo kakvu vrstu automatizacije korištenjema Ansible alata potrebno je definisati za koje host-ove je zadužen Ansible. Inventories nam pružaju mogućnost definisanja istih. Ansible inventories se mogu dostaviti u više formata; mogu biti statičke ili dinamičke, i mogu sadržavati bitne varijable na osnovu kojih Ansible pravi odluke pri interakciji sa host-ovima. \\\\
Inventory se sastoji od: hostova, varijabli i grupa. Hostovi predstavljaju domenu ili ip adresu mašina kojima želimo upravljati. Grupe omogućavaju da host-ove grupiramo po nekim osobinama ili ulogama. Varijable možemo definisati na nivou host-a ili grupe. Ako dodijelimo varijablu na nivou grupe svi host-ovi unutar te grupe koriste definisanu varijablu.
\subsubsection{Statični inventory}
Kako samo ime govori statični inventory je statične prirode. Korisnik definiše ručno file u kojem navodi za koje host-ove je Ansible zadužen. Kada se jednom definišu njihova vrijednost se ne mijenja osim ako korisnik ručno ne napravi promjene. Ovaj način je dobar ako je broj mašina kojima se treba upravljat mali i nije promjenjive prirode ili su promjene ne tako česte.\\\\
Ansible zadano koristi inventory koji se nalazi u \textbf{/etc/ansible/hosts}. Iako možemo koristiti grupe unutar inventory file-a preporučljivo je kreirati inventory za svaki projekat zasebno. Da bi naložili Ansible-u da koristi specifični inventory to možemo uraditi na sljedeći način.
\begin{lstlisting}
ansible -i InventoryName.yaml all -m ping
\end{lstlisting}
Sa -i zastavicom specificirali smo da ansible koristi inventory koji se nalazi u InventoryName.yaml. Opcija all nalaže da Ansible odradi playbook nad svim hostovima odnosno grupama unutar definisanog inventory-ija. Napomena: Ako koristite relativnu putanju onda se morate nalaziti u direktoriji u kojoj se nalazi i inventory. \\\\
Inventory se sastoji od imena grupa, host-ova i varijabli. Zadane grupe koje postoje su all i ungrouped.
Definicija inventory.yaml koja definiše host-ove kreairane od strane Vagrant-a data je ispod.
\begin{lstlisting}
all:
  hosts:
    u1:
      ansible_host: 192.168.33.10
      ansible_ssh_private_key_file: /home/qdnqn/vagrant/.vagrant/machines/u1/virtualbox/private_key
    u2:
      ansible_host: 192.168.33.11
      ansible_ssh_private_key_file: /home/qdnqn/vagrant/.vagrant/machines/u2/virtualbox/private_key
  children:
    vagrant:
      hosts:
        u1:
        u2:
      vars:
        ansible_user: vagrant
\end{lstlisting}
Napomena! Vagrant zadano kreira par javni/privatni ključ pri kreiranju mašine. Također zadani username je \textbf{vagrant}. Da bi vidjeli SSH postavke koje Vagrant koristi potrebno je da u direktoriju, gdje se nalazi Vagrantfile, pokrenemo vagrant ssh-config komandu. Ispis će nam prikazati detaljne informacije o SSH konfiguraciji za svaku virtualnu mašinu. Između ostalog i putanju na host mašini do privatnog ključa potrebnog za autentifikaciju pri SSH konekciji. Tu vrijednost je potrebno upisati u ansible\_ssh\_private\_key\_file. \\\\
Pokretanjem sljedeće komande možemo provjeriti da li smo dobro definisali inventory.
\begin{lstlisting}
ansible -i inventory.yaml all -m ping
\end{lstlisting}
Sa zastavicom -m definišemo koji modul želimo da Ansible odradi. Ping je jednostavan modul koji vraća pong kao rezultat ako je sve uredu.\\\\
Nakon pokretanja ove komande Ansible na terminalu vrati sljedeći ispis
\begin{lstlisting}
u2 | SUCCESS => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python"
    },
    "changed": false,
    "ping": "pong"
}
u1 | SUCCESS => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python"
    },
    "changed": false,
    "ping": "pong"
}
\end{lstlisting}
Vidimo da je ping modul uspješno odrađen na upravljivim mašinama: u1 i u2. \\\\
Inventory nam nudi velike mogućnosti pri konfigurisanju bihevioralnih parametara. Izdvojit ćemo par parametara koje je moguće konfigurisati pri definiciji inventory-ija:
\begin{itemize}
    \item ansible\_host
    \item ansible\_port
    \item ansible\_user
    \item ansible\_password
    \item ansible\_ssh\_private\_key\_file
    \item ansible\_shell\_type
    \item ansible\_connection
\end{itemize}
Listu svih parametara koje je moguće konfigurisati se može pronaći na oficijelnoj dokumentaciji Ansible-a. \\\\
Iako je moguće u jednom inventory file-u konfigurisati sve host-ove kojima želimo upravljati, na većim projektima poželjno je razdvojiti inventory koristeći strukturu direktorija. \\ Ako napravimo sljedeću strukturu direktorija: \\\\
{\footnotesize
\begin{forest}
  for tree={
    font=\ttfamily,
    grow'=0,
    child anchor=west,
    parent anchor=south,
    anchor=west,
    calign=first,
    edge path={
      \noexpand\path [draw, \forestoption{edge}]
      (!u.south west) +(7.5pt,0) |- node[fill,inner sep=1.25pt] {} (.child anchor)\forestoption{edge label};
    },
    before typesetting nodes={
      if n=1
        {insert before={[,phantom]}}
        {}
    },
    fit=band,
    before computing xy={l=15pt},
  }
[project
    [inventory
      [group\_vars
        [vagrant.yaml, file
        ]
      ]
      [host\_vars
        [u1.yaml, file
        ]
        [u2.yaml, file
        ]
      ]
      [hosts.yaml, file
      ]
    ]
]
\end{forest}
}
\\
Na ovaj način su razdvojene varijable po grupama i po hostovima, korištenjem strukture direktorija. Sadržaj hosts.yaml je dat ispod.
\begin{lstlisting}
all:
  hosts:
    u1:
    u2:
  children:
    vagrant:
      hosts:
        u1:
        u2:
\end{lstlisting}
Sadržaj vagrant.yaml dat je ispod.
\begin{lstlisting}
ansible_user: vagrant
\end{lstlisting}
Sadržaj u1.yaml i u2.yaml je dat ispod.
\begin{lstlisting}
ansible_host: 192.168.33.10
ansible_ssh_private_key_file: /home/qdnqn/vagrant/.vagrant/machines/u1/virtualbox/private_key
\end{lstlisting}
\begin{lstlisting}
ansible_host: 192.168.33.11
ansible_ssh_private_key_file: /home/qdnqn/vagrant/.vagrant/machines/u2/virtualbox/private_key\end{lstlisting}
Možemo zaključiti da je preglednost i lahkoća održavanja mnogo veća u slučaju da je potrebno skalirati projekat na mnogo veći broj host-ova. Što se tiče definicije i konfiguracije ništa se nije promijenilo u odnosu na inventory.yaml sa početka.\\\\
Pri definisanju hosts.yaml moramo ispoštovati konvenciju u pogledu definisanja all i hosts elemenata, tj. to su elementi koje moramo definisati u yaml file-u. Ako nekom host-u ne dodijelimo grupu on se automatski grupira u ungrouped.
\subsubsection{Dinamički inventory}
Zahvaljujući pojavi cloud tehnologija host-ovi se mogu mijenjati na dnevnoj ako ne jednosatnoj bazi. Statički inventory u tom slučaju ne bi bio od velike pomoći. Da se statički inventory održi ažuriranim bio bi zahtjevan posao, a u pogledu aplikacija velikih razmjera bilo bi nemoguće održati ažuriranost sa pravovremenim podacima. Ansible rješava taj problem sa dinamičkim invetory-ima. Ansible može pokupiti podatke o host-ovima sa bilo kojeg izvršnog file-a (eng. executable). Moguće je kreirati skriptu koja bi radila taj posao za vas. Međutim postoji već mnogo kreiranih rješenja za dinamički inventory koji podržava razne izvore podataka među kojima su: Amazon EC2, Microsoft Azure, LDAP directories i mnogi drugi.
\subsubsection{Dinamički inventory: Amazon AWS}
Za primjer dinamičkog inventory-ija uzet je Amazon AWS EC2 instances. Ansible se oslanja na python boto3 modul koji je potrebno instalirati da bi mogli koristiti ansible AWS EC2 plugin.
\begin{lstlisting}
sudo pip3 install boto3
\end{lstlisting}
Definisanje dinamičkog inventory-a je različito za svakog drugog provajdera jer koriste različite plugin-ove. Da bi uopšte omogućili Ansible-u da pravi AWS REST upite prema AWS service API-u potrebno je generisati Access key za korisnika koji ima \textbf{eng. Programmatic access}.

\begin{figure}[H]
\centering
 \includegraphics[scale=0.5]{slike/add_aws_user.png}
 \caption{Dodavanje novog korisnika sa dovoljnim pristupom na AWS platformi.}
 \label{ref_slika2}
\end{figure}

\begin{figure}[H]
\centering
 \includegraphics[scale=0.5]{slike/access_keys.png}
 \caption{Dodavanje novog access key-a na AWS platformi.}
 \label{ref_slika2}
\end{figure}
\newpage
Sa kreiranim ključevima potrebno je definisati dinamički inventory korištenjem već dostupnog modula \textbf{aws\_ec2}. Sadržaj od aws.aws\_ec2.yaml je dat ispod.
\begin{lstlisting}
plugin: aws_ec2

aws_access_key: <ACCESS_ID>
aws_secret_key: <SECRET_KEY>

regions:
  - us-east-2
hostnames:
  - dns-name
  
strict_permissions: False
\end{lstlisting}
Na slici ispod je prikazan EC2 dashboard u dva slučaja.
\begin{figure}[H]
\centering
 \includegraphics[scale=0.81]{slike/instance1_cropped.png}
 \caption{AWS EC2 dashboard sa jednom pokrenutom instancom.}
 \label{ref_slika2}
\end{figure}
\begin{figure}[H]
\centering
 \includegraphics[scale=0.81]{slike/instance2_cropped.png}
 \caption{AWS EC2 dashboard sa dvije pokrenute instance.}
 \label{ref_slika2}
\end{figure}
Prvi slučaj je prikazan kada je samo pokrenuta jedna instanca, a drugi kada su pokrenute dvije instance. Između kreiranja svake instance pokrenuta je sljedeća komanda.
\begin{lstlisting}
ansible-inventory -i aws.aws_ec2.yaml --graph
\end{lstlisting}
Na slici ispod prikazani su rezultati.
\begin{figure}[H]
\centering
 \includegraphics[scale=0.81]{slike/bash.png}
 \caption{Prikaz stanja dinamičkog inventory-a.}
 \label{ref_slika2}
\end{figure}
Vidimo da je inventory automatski ažuriran bez ikakve intervencije nad inventory-ijem. Prednosti koje nudi ovakav pristup u okruženju gdje se instance rađaju i umiru na nivou sati je ogroman.\\\\
Ansible pruža i mogućnost korištenja statičnog i dinamičkog inventory-ija kombinovano.
\subsection{Ad hoc komande}
Ad hoc komande služe da direktno iz terminala pokrenemo Ansible module. Neke ad hoc komande su već korištene u radu. Primjer takve komande je dat ispod.
\begin{lstlisting}
ansible -i ansible/inventory/inventory.yaml all -m ping
\end{lstlisting}
Ad hoc komande su korisne u sljedećim slučajevima:
\begin{itemize}
    \item Reboot mašina
    \item File menadžment
    \item Menadžment korisnika i grupa
    \item Menadžment servisa
\end{itemize}
Primjer menadžmenta servisa dat je ispod.
\begin{lstlisting}
ansible webservers -m ansible.builtin.service -a "name=httpd state=restarted"
\end{lstlisting}
\subsection{Ansible playbooks}
Iako su ad hoc komande koristan alat za izvršavanje jednostavnijih modula prava moć automatizacije se nalazi u IaC. Ansible nam omogućava da grupišemo zadatke (dalje u tekstu \textbf{eng. task}) u određene grupe. Logička grupacija task-ova naziva se \textbf{Playbook}. Ansible nam omogućava da definišemo playbook u obliku YAML zapisa. \\\\
Playbook nam omogućava da upravljamo različitim konfiguracijama i kompleksnim deployment-ima. Playbooks se također kao i ad hoc komande oslanjaju na inventory. Playbook predstavlja glavni način definisanja automatizacije task-ova u Ansible-u.
Playbook definišemo korištenjem yaml zapisa koji predstavlja ništa drugo do listu task-ova koji se izvšavaju jasno određenim redoslijedom. Svaki task pokreće određeni Ansible modul koji odradi zahtjevanu akciju na upravljivim host-ovima.
\subsubsection{Kreiranje playbook-a}
Kako smo naveli playbook se definiše u yaml zapisu i to čuvanjem u file-ovim sa .yaml/.yml ekstenzijom. Ispod je data definicija jednostavnog playbook-a \textbf{project/user.yaml}. Task koji smo kreirali koristi ugrađeni modul users koji omogućava administriranje korisnika na linux operativnom sistemu. Sa \textbf{state: present} definišemo da je željeno stanje da korisnik postoji.
\begin{lstlisting}
- name: Add new user playbook
  hosts: all
  become: yes
  tasks:
    - name: Add new user task
      user:
        name: qdnqn
        uid: 4000
        state: present
\end{lstlisting}
Da bi pokrenuli dati playbook potrebno je izvršiti sljedeću komandu.
\begin{lstlisting}
ansible-playbook -i inventory user.yaml
\end{lstlisting}
Ispis na ekranu će biti sljedeći (ako ne postoji korisnik sa UID 4000 i imenom qdnqn).
\begin{lstlisting}
PLAY [Add new user playbook] **************************

TASK [Gathering Facts] ********************************
ok: [u2]
ok: [u1]

TASK [Add new user task] *******************************
changed: [u1]
changed: [u2]

PLAY RECAP *********************************************
u1: ok=2    changed=1    unreachable=0  [OMMITED OUTPUT]
u2: ok=2    changed=1    unreachable=0  [OMMITED OUTPUT]
\end{lstlisting}
Vidimo da se task izvršio uspješno na svakoj upravljivoj mašini (ok). Također korisnici su kreirani na mašinama u1 i u2 (changed). Ako opet pokrenemo isti playbook ispis će biti sljedeći. \newpage
\begin{lstlisting}
PLAY [Add new user playbook] ****************************

TASK [Gathering Facts] **********************************
ok: [u1]
ok: [u2]

TASK [Add new user task] ********************************
ok: [u2]
ok: [u1]

PLAY RECAP **********************************************
u1: ok=2    changed=0   [OMMITED OUTPUT]  
u2: ok=2    changed=0   [OMMITED OUTPUT] 
\end{lstlisting}
Ako analiziramo ispis nakon druge iteracije izvršavanja vidimo da se ispis promjenio. Tačnije \textbf{changed=0} nam govori da se, nakon izvršenja playbooka \textbf{project/users.yaml}, stanje na mašinama nije promjenilo jer korisnik sa zadanim parametrima već postoji.
\subsubsection{Korištenje varijabli i petlji u playbook-a}
Ansible nam omogućava definisanje varijabli i substituciju vrijednosti varijabli unutar playbook-a. Varijable smo već koristili za kreiranje inventory-ija. Definisali smo \textbf{host\_vars} i \textbf{group\_vars}. Primjer korištenja varijabli unutar playbook-a dat je ispod u file-u \textbf{project/user\_vars.yaml}.
\begin{lstlisting}
- name: Add new user playbook
  hosts: all
  become: yes
  vars: 
    username: qdnqn
  tasks:
    - name: Add new user task
      user:
        name: "{{ username }}"
        uid: 4000
        state: present
\end{lstlisting}
Varijablu smo definisali u elementu \textbf{vars} dok smo substituciju izvršili u \textbf{name} elementu. Substituciju vrijednosti vršimo pomoću \textbf{"\{\{ ime\_varijable \}\}"}.\\\\
Ispod je dat primjer korištenja petlji.
\begin{lstlisting}
- name: Add new user playbook
  hosts: all
  become: yes
  vars: 
    usernames: 
      - qdnqn1
      - qdnqn2
      - qdnqn3
  tasks:
    - name: Add new user task
      user:
        name: "{{ item }}"
        state: present
      loop: "{{ usernames }}"
\end{lstlisting}
\subsubsection{Uslovno izvršavanje task-ova}
Kao dodatni parametar pri definisanju nekog task-a postoji i when. When služi za kreiranje uslovnog izvršavanja nekog task-a. Dakle omogućeno je definisati uslov pri kojem će se task izvršiti. Ansible automatski izvršava ugrađeni task \textbf{gather\_facts}. On se izvršava početkom izvršavanja playbook-a ili adhoc komande. Ovaj task nam prikupi informacije sa upravljive mašine. Prije nego se task-ovi počnu izvršavati imamo informacije sa upravljive mašine. Te informacije su veoma korisne prilikom korištenja uslovnog izvršavanja.\\\\
Ispod je dat primjer playbook-a sa uslovnim izvršavanjem.
\begin{lstlisting}
- name: Conditional execution
  hosts: all
  become: yes
  gather_facts: true
  vars:
    supported_os_yum:
      - RedHat
      - Fedora
    supported_os_apt:
      - Ubuntu

  tasks:
    - name: Install htop using yum
      yum:
        name: htop
        state: present
      when: ansible_facts['distribution'] in supported_os_yum

    - name: Install htop using apt
      apt:
        name: htop
        state: present
      when: ansible_facts['distribution'] in supported_os_apt
\end{lstlisting}
Playbook iznad zadužen je za instalaciju \textbf{htop} paketa na upravljivoj mašini. Različite distribucije linux operativnog sistema koriste različite menadžere paketa. Ova činjenica je iskorištena da demonstriramo uslovno izvršavanje. Korištenjem \textbf{when: ansible\_facts['distribution'] in supported\_os\_apt} ograničavamo ovaj task da se izvrši samo kada se distribucija operativnog sistema upravljive mašine nalazi u listi \textbf{supported\_os\_apt}. Za drugi task to je lista \textbf{supported\_os\_yum}.
\\\\
Ansible koristi niz standardnih operatora koje je moguće u koristiti pri kreiranju uslova, kao što su: \textbf{==}, \textbf{<}, \textbf{>}, itd... Čitava lista dostupna je u dokumentaciji. Ansible također podržava provjeru više uslova korištenjem boolean operatora \textbf{and} i \textbf{or}.
\\\\
Primjer \textbf{inline eng.} uslovljavanja dat je ispod.
\begin{lstlisting}
when: ansible_facts['distribution'] == "RedHat" or ansible_facts['distribution'] == "Fedora" 
\end{lstlisting}
\newpage\subsubsection{Handlers}
Ansible nam omogućava automatsku aktivaciju task-ova. Ako je potrebno pokrenuti neki task kao posljedicu izmjene nekog drugog task-a, koristimo handler-e. Handler nije ništa drugo do task. To implicira da sve što važi za task-ove, važi i za handler-e. \\\\
Handler na globalnom nivou mora imati jedinstveno ime. Task koji poziva handler, radi to pomoću elementa \textbf{notify}.
Da bi neki task pozvao handler koristi se sljedeća sintaksa.
\begin{lstlisting}
---
- name: Set hostname of managed machine
  hosts: all
  become: yes
  tasks:
    - name: Set hostname
      hostname:
        name: u1
      notify: Display hostname
      when: ansible_facts['ansible_hostname'] == "u1" 

  handlers:
    - name: Display hostname
      become: true
      command:
        cmd: cat /etc/hostname 
      register: hostname
      notify: debug
    
    - name: debug
      debug:
        var: hostname
\end{lstlisting}
Vidimo da bi u task-u omogućili pozivanje handler-a koristimo
\begin{lstlisting}
notify: Display hostname
\end{lstlisting}
Dakle pozivamo handler po njegovom imenu. \\\\
Handler-e najčešće koristimo kada je potrebno izvršiti reboot upravljive mašine ili restart servisa.
\subsection{Include, import i roles}
\subsubsection{Include i import}
Razvojem projekta playbook moze dostići tačku kada nije moguće lagano održavanje zbog njegovog obima. Ansible nam omogućava da razdvojimo yaml file na više načina i koristimo uvoz. Uvoz \textbf{eng. include} nam omogućava da unutar jednog playbook-a uvezemo task, handler ili cijeli playbook. Način na koji uvozimo handler-e je isti za uvoz task-ova. Ansible omogućava dvije vrste uvoza: statički uvoz i dinamički uvoz. Dinamički uvoz je omogućen sa include, a statički sa import. 
\\\\
Primjer je dat ispod (\textbf{project/handlers\_include.yaml}).
\begin{lstlisting}
---
- name: Set hostname of managed machine
  hosts: all
  become: yes
  gather_facts: true
  tasks:
    - name: Set hostname
      hostname:
        name: u1
      notify: Display hostname
      when: ansible_facts['hostname'] == "u1" 

  handlers:
    - include: "handlers/display_hostname.yaml"
    - include: "handlers/debug_handler.yaml"
\end{lstlisting}
Glavna razlika između include i import je u tome što include uvozi dodatne yaml file-ove pri runtime-u (Može se koristiti i u petljama), dok import uvozi pri parsiranju playbook-a (Uvozi samo jednom i ne može se koristiti u petljama).
\subsubsection{Roles}
Jedan od glavnih načina dijeljenja i izvoza ansible playbook-ova je korištenjem \textbf{roles}-a. Definisana je standardna struktura koja se koristi za roles i data je ispod. \\\\
{\footnotesize
\begin{forest}
  for tree={
    font=\ttfamily,
    grow'=0,
    child anchor=west,
    parent anchor=south,
    anchor=west,
    calign=first,
    edge path={
      \noexpand\path [draw, \forestoption{edge}]
      (!u.south west) +(7.5pt,0) |- node[fill,inner sep=1.25pt] {} (.child anchor)\forestoption{edge label};
    },
    before typesetting nodes={
      if n=1
        {insert before={[,phantom]}}
        {}
    },
    fit=band,
    before computing xy={l=15pt},
  }
[project
    [inventory
      [..., file
      ]
    ],
    [roles
      [ role1
        [tasks, file
        ]
        [handlers, file
        ]
        [templates, file
        ]
        [vars, file
        ]
        [files, file
        ]
        [library, file
        ]
        [defaults, file
        ]
      ]
    ]
]
\end{forest}
}
\\
Unutar svakog direktorija u role1 nalazi se main.yaml file, ako je taj direktorij potreban za određeni role. U većini slučajeva nisu vam potrebni svih 7 direktorija. Međutim one koje koristite potrebno je kreirati. 
\\\\
Role se uvoze na sljedeći način, unutar playbook-a.
\begin{lstlisting}
---
- hosts: all
  roles:
    - role1
\end{lstlisting}
\subsection{Jinja2 templates}

\end{document}